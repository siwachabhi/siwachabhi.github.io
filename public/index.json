[{"content":"Introduction AWS is great for quickly prottyping infrastructure and flexibility of defining applications. This also introduces some complexity around understanding new concepts related to networking, which developers might not be familiar with. This blog introduces basic AWS networking concepts.\nGlossary VPC (Virtual Private Cloud): A virtual network that provides isolation and security for resources within AWS. Think of it as a private data center in the cloud. Subnet: A subset of a VPC that allows you to divide the network into smaller segments. Subnets only provides a logic way of grouping IP addresses(not a firewall), all IP addresses within a VPC are accessible from resources in different subnets. Route Table: A set of rules that determines where network traffic is directed. These are specific per subnet. Security Group: A virtual firewall that controls inbound and outbound traffic for resources within AWS. CIDR: Notation to represent IP address range, with IP address followed by a / and a number that specifies the number of bits in the network prefix. For example, a CIDR notation of \u0026ldquo;10.0.0.0/16\u0026rdquo; represents an IP address range that includes all IP addresses from 10.0.0.0 to 10.0.255.255. When you create a VPC, you can specify the IP address range and the number of subnets you want to create. Each subnet has a unique IP address range and can be associated with a different availability zone. Once you have created your VPC and subnets, you can launch resources such as EC2 instances, NLB, et. within your VPC. When you launch a resource, you can specify the subnet and the security group that it should be associated with.\nSetting up a vpc with code Using boto3 to explain the best practice of setting up a AWS vpc with separate route table for private and public subnets. This is to isolate resources in private subnet from any access from internet. A public subnet has internet gateway(IGW) and network address translator(NAT) with route table of public subnet forwarding traffic to default IP(0.0.0.0/0) to internet gateway. Route table of private subnet forwards traffic for default IP to NAT in public subnet. NAT takes care of forwarding traffic to IGW and response back to resources in private subnet.\nIn production, CDK can automate most of this and apply best practices.\nimport boto3 # Create an EC2 client ec2 = boto3.client(\u0026#39;ec2\u0026#39;) # Create the VPC response = ec2.create_vpc(CidrBlock=\u0026#39;10.0.0.0/16\u0026#39;) vpc_id = response[\u0026#39;Vpc\u0026#39;][\u0026#39;VpcId\u0026#39;] # Add a name tag to the VPC ec2.create_tags(Resources=[vpc_id], Tags=[{\u0026#39;Key\u0026#39;: \u0026#39;Name\u0026#39;, \u0026#39;Value\u0026#39;: \u0026#39;MyVPC\u0026#39;}]) # Create an internet gateway and attach it to the VPC response = ec2.create_internet_gateway() igw_id = response[\u0026#39;InternetGateway\u0026#39;][\u0026#39;InternetGatewayId\u0026#39;] ec2.attach_internet_gateway(InternetGatewayId=igw_id, VpcId=vpc_id) # Create a public subnet response = ec2.create_subnet(CidrBlock=\u0026#39;10.0.1.0/24\u0026#39;, VpcId=vpc_id) public_subnet_id = response[\u0026#39;Subnet\u0026#39;][\u0026#39;SubnetId\u0026#39;] ec2_client.create_route(RouteTableId=\u0026#39;\u0026lt;public_route_table_id\u0026gt;\u0026#39;, DestinationCidrBlock=\u0026#39;0.0.0.0/0\u0026#39;, GatewayId=internet_gateway_id) # Create a private subnet response = ec2.create_subnet(CidrBlock=\u0026#39;10.0.2.0/24\u0026#39;, VpcId=vpc_id) private_subnet_id = response[\u0026#39;Subnet\u0026#39;][\u0026#39;SubnetId\u0026#39;] # Create a NAT gateway in the public subnet response = ec2.create_nat_gateway(SubnetId=public_subnet_id, AllocationId=\u0026#39;\u0026lt;allocation_id\u0026gt;\u0026#39;) nat_gateway_id = response[\u0026#39;NatGateway\u0026#39;][\u0026#39;NatGatewayId\u0026#39;] # Update the route table for the private subnet to use the NAT gateway # NAT acts a reverse proxy to take in traffic from private subnet and forward to IGW and vice-versa. response = ec2.create_route(RouteTableId=\u0026#39;\u0026lt;private_route_table_id\u0026gt;\u0026#39;, DestinationCidrBlock=\u0026#39;0.0.0.0/0\u0026#39;, NatGatewayId=nat_gateway_id) # Allow resources in the public subnet to access resources in the private subnet response = ec2.modify_subnet_attribute(SubnetId=private_subnet_id, MapPublicIpOnLaunch={\u0026#39;Value\u0026#39;: False}) print(f\u0026#34;VPC ID: {vpc_id}\u0026#34;) print(f\u0026#34;Public Subnet ID: {public_subnet_id}\u0026#34;) print(f\u0026#34;Private Subnet ID: {private_subnet_id}\u0026#34;) print(f\u0026#34;NAT Gateway ID: {nat_gateway_id}\u0026#34;) Setting up EC2 instance in private subnet of vpc import boto3 # Create an EC2 client ec2 = boto3.client(\u0026#39;ec2\u0026#39;) # Get the ID of the private subnet private_subnet_id = \u0026#39;private-subnet-id\u0026#39; # Create a security group security_group_name = \u0026#39;private-security-group\u0026#39; response = ec2.create_security_group(GroupName=security_group_name, Description=\u0026#39;Allow TCP traffic on port 8082 from anywhere\u0026#39;, VpcId=\u0026#39;\u0026lt;vpc_id\u0026gt;\u0026#39;) security_group_id = response[\u0026#39;GroupId\u0026#39;] # Add an ingress rule to allow TCP traffic on port 8082 ec2.authorize_security_group_ingress(GroupId=security_group_id, IpPermissions=[{\u0026#39;IpProtocol\u0026#39;: \u0026#39;tcp\u0026#39;, \u0026#39;FromPort\u0026#39;: 8082, \u0026#39;ToPort\u0026#39;: 8082, \u0026#39;IpRanges\u0026#39;: [{\u0026#39;CidrIp\u0026#39;: \u0026#39;10.0.0.0/16\u0026#39;}]}]) # Launch an EC2 instance in the private subnet with the security group image_id = \u0026#39;\u0026lt;ami_id\u0026gt;\u0026#39; instance_type = \u0026#39;t2.micro\u0026#39; key_name = \u0026#39;\u0026lt;key_name\u0026gt;\u0026#39; private_ip_address = \u0026#39;10.0.2.10\u0026#39; # Replace with an IP address within the private subnet range user_data = \u0026#39;#!/bin/bash\\necho \u0026#34;Hello, World!\u0026#34; \u0026gt; index.html \u0026amp;\u0026amp; nohup python -m SimpleHTTPServer 8082 \u0026amp;\u0026#39; response = ec2.run_instances(ImageId=image_id, InstanceType=instance_type, KeyName=key_name, SecurityGroupIds=[security_group_id], SubnetId=private_subnet_id, PrivateIpAddress=private_ip_address, UserData=user_data) instance_id = response[\u0026#39;Instances\u0026#39;][0][\u0026#39;InstanceId\u0026#39;] print(f\u0026#34;EC2 instance {instance_id} launched in private subnet with IP address {private_ip_address} and security group {security_group_id}\u0026#34;) ","permalink":"https://siwachabhi.github.io/posts/aws-networking-basics/","summary":"Introduction AWS is great for quickly prottyping infrastructure and flexibility of defining applications. This also introduces some complexity around understanding new concepts related to networking, which developers might not be familiar with. This blog introduces basic AWS networking concepts.\nGlossary VPC (Virtual Private Cloud): A virtual network that provides isolation and security for resources within AWS. Think of it as a private data center in the cloud. Subnet: A subset of a VPC that allows you to divide the network into smaller segments.","title":"AWS networking basics"},{"content":"Introduction AWS is excellent to quickly protoype infrastructure proposals. We can access AWS console, manually spin up any service we want, experiment with it and spin it down. When moving to production, we can manage AWS infrastructure as code using CDK and keep it up to date with cloudformation deployments, ensuring software development CI/CD best practices.\nProblem There is an apparent gap between these two stages, if infrastructure to be setup is fairly complex and team wants to move very fast to production, to enable faster time to market. These are scenarios where manually creating all of the infrastructure is error prone and time consuming. On the other hand, auatomating using CDK/cloudaformation is too slow.\nSolution Python boto3 client provides excellent apis to access AWS control plane. Python\u0026rsquo;s fast scripting prowess and intuitive boto3 apis, opens up a middle ground to automate AWS infrastructure operations and still provide a faster time to market. Team can then eventually use CDK to automate complete infrastructure management and deployment.\nExample Consider a scenario of enabling cross vpc access for MSK via private link. Here is an AWS blog, which explains the solution but in practice there are so many moving pieces that it becomes hard to even set this up once, to think if we have to perform the same setup in multiple regions/stages is daunting to say the least.\nRest of the blog assumes pattern-2 setup, as its more frugal in terms of cost. Source: AWS blog how goldman sachs builds cross account connectivity to their amazon msk clusters with aws privatelink\nNote: Below code examples are just to express the idea, might not work as it is.\nSetting up VPC Setup a vpc with 3 private subnet, 3 public subnet.\n# Create the VPC response = ec2_client.create_vpc(CidrBlock=\u0026#39;10.0.0.0/16\u0026#39;) vpc_id = response[\u0026#39;Vpc\u0026#39;][\u0026#39;VpcId\u0026#39;] # Create the public subnets public_subnet_cidr_blocks = [\u0026#39;10.0.1.0/24\u0026#39;, \u0026#39;10.0.2.0/24\u0026#39;, \u0026#39;10.0.3.0/24\u0026#39;] public_subnet_ids = [] for cidr_block in public_subnet_cidr_blocks: response = ec2_client.create_subnet(CidrBlock=cidr_block, VpcId=vpc_id) public_subnet_ids.append(response[\u0026#39;Subnet\u0026#39;][\u0026#39;SubnetId\u0026#39;]) # Create the private subnets private_subnet_cidr_blocks = [\u0026#39;10.0.4.0/24\u0026#39;, \u0026#39;10.0.5.0/24\u0026#39;, \u0026#39;10.0.6.0/24\u0026#39;] private_subnet_ids = [] for cidr_block in private_subnet_cidr_blocks: response = ec2_client.create_subnet(CidrBlock=cidr_block, VpcId=vpc_id) private_subnet_ids.append(response[\u0026#39;Subnet\u0026#39;][\u0026#39;SubnetId\u0026#39;]) Setting up MSK cluster Setup a MSK with private subnets of above vpc, with a security group allowing traffic to broker and zookeeper nodes.\n# Get the IDs of the VPC and private subnets vpc_id = \u0026#39;your_vpc_id\u0026#39; private_subnet_ids = [\u0026#39;your_private_subnet_id_1\u0026#39;, \u0026#39;your_private_subnet_id_2\u0026#39;, \u0026#39;your_private_subnet_id_3\u0026#39;] # Create the security group for MSK response = ec2_client.create_security_group( GroupName=\u0026#39;msk-sg\u0026#39;, VpcId=vpc_id, ) msk_security_group_id = response[\u0026#39;GroupId\u0026#39;] # Allow ingress traffic to msk and zookeeper ports response = msk_client.create_cluster( ClusterName=\u0026#39;your_cluster_name\u0026#39;, KafkaVersion=\u0026#39;2.7.0\u0026#39;, NumberOfBrokerNodes=3, BrokerNodeGroupInfo={ \u0026#39;InstanceType\u0026#39;: \u0026#39;kafka.m5.large\u0026#39;, \u0026#39;ClientSubnets\u0026#39;: private_subnet_ids, \u0026#39;SecurityGroups\u0026#39;: [msk_security_group_id], } ) Setting up NLB # Get the IDs of the VPC and private subnets vpc_id = \u0026#39;your_vpc_id\u0026#39; private_subnet_ids = [\u0026#39;your_private_subnet_id_1\u0026#39;, \u0026#39;your_private_subnet_id_2\u0026#39;, \u0026#39;your_private_subnet_id_3\u0026#39;] # Set up the NLB listener ports and target groups nlb_listener_ports = [7001, 7002, 7003] nlb_target_groups = [] for i in range(len(nlb_listener_ports)): port = nlb_listener_ports[i] target_group_name = f\u0026#39;msk-tg-{port}\u0026#39; target_group_response = elbv2_client.create_target_group( Name=target_group_name, Protocol=\u0026#39;TCP\u0026#39;, Port=port, VpcId=vpc_id, ) target_group_arn = target_group_response[\u0026#39;TargetGroups\u0026#39;][0][\u0026#39;TargetGroupArn\u0026#39;] nlb_target_groups.append(target_group_arn) # Set up the NLB nlb_name = \u0026#39;your_nlb_name\u0026#39; nlb_response = elbv2_client.create_load_balancer( Name=nlb_name, Subnets=private_subnet_ids, Type=\u0026#39;network\u0026#39;, ) nlb_arn = nlb_response[\u0026#39;LoadBalancers\u0026#39;][0][\u0026#39;LoadBalancerArn\u0026#39;] # Attach the target groups to the NLB # Create the VPC endpoint service, so that clients can creat an endpoint to this in their vpc. # Clients will need to create dns entry in their vpc, which will forward traffic to their endpoint. # Get the details of the MSK brokers msk_client = boto3.client(\u0026#39;kafka\u0026#39;) msk_brokers_response = msk_client.list_nodes(ClusterArn=\u0026#39;your_msk_cluster_arn\u0026#39;) msk_brokers = msk_brokers_response[\u0026#39;NodeInfoList\u0026#39;] # Register the MSK brokers with the NLB target groups for i in range(len(nlb_target_groups)): target_group_arn = nlb_target_groups[i] msk_broker = msk_brokers[i] client_vpc_address = msk_broker[\u0026#39;ClientVpcIpAddress\u0026#39;] ec2_instance_id = ec2_client.describe_instances(Filters=[{\u0026#39;Name\u0026#39;: \u0026#39;private-ip-address\u0026#39;, \u0026#39;Values\u0026#39;: [client_vpc_address]}])[\u0026#39;Reservations\u0026#39;][0][\u0026#39;Instances\u0026#39;][0][\u0026#39;InstanceId\u0026#39;] target_response = elbv2_client.register_targets( TargetGroupArn=target_group_arn, Targets=[{\u0026#39;Id\u0026#39;: ec2_instance_id, \u0026#39;Port\u0026#39;: 9092}], ) Modify advertised listener of MSK brokers AWS has good documentation for this, essentially we need to modify advertised.listener configuration of each broker. To do this we can create a EC2 instance in public subnet of MSK, and perform kafka cli setup. While modifying DNS we will also need to update it to match to the external dns that clients will create in their private hosted zone.\n#!/bin/bash MSK_DNS=\u0026#34;\u0026lt;msk-cluster-dns-name\u0026gt;\u0026#34; CUSTOM_DNS_NAME=\u0026#34;\u0026lt;custom-external-dns-name-for-nlb-clients\u0026gt;\u0026#34; PORT_START=7000 for ((BROKER_ID=1; BROKER_ID\u0026lt;=3; BROKER_ID++)) do ((PORT=PORT_START+BROKER_ID)) CONFIG_VALUE=\u0026#34;advertised.listeners=[CLIENT://$CUSTOM_DNS_NAME:$PORT,CLIENT_SECURE://b-$BROKER_ID_START.$MSK_DNS:9094,REPLICATION://b-$BROKER_ID_START-internal.$MSK_DNS:9093,REPLICATION_SECURE://b-$BROKER_ID_START-internal.$MSK_DNS:9095]\u0026#34; echo \u0026#34;Updating $ENTITY_TYPE $ENTITY_NAME config property to $CONFIG_VALUE\u0026#34; ./kafka-configs.sh --bootstrap-server \u0026#34;b-1.$MSK_DNS:9094\u0026#34; --entity-type \u0026#34;brokers\u0026#34; --entity-name \u0026#34;1\u0026#34; --alter --command-config client.properties --add-config $CONFIG_VALUE done Take Aways Even in scenarios of urgent time to market scenario, prefer to automate infrastructure setup. With high flexibility of AWS infrastructure, it also creates scenarios of manual misses, at the bare mimum use boto3 for quick and dirty automation. Long term prefer CDK for AWS infrastructure management via CI/CD integration.\n","permalink":"https://siwachabhi.github.io/posts/quick-aws-infra-automation/","summary":"Introduction AWS is excellent to quickly protoype infrastructure proposals. We can access AWS console, manually spin up any service we want, experiment with it and spin it down. When moving to production, we can manage AWS infrastructure as code using CDK and keep it up to date with cloudformation deployments, ensuring software development CI/CD best practices.\nProblem There is an apparent gap between these two stages, if infrastructure to be setup is fairly complex and team wants to move very fast to production, to enable faster time to market.","title":"Quick AWS Infrastructure automations with python boto3"}]